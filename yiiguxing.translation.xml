<application>
  <component name="AppStorage">
    <option name="newTranslationDialogX" value="624" />
    <option name="newTranslationDialogY" value="775" />
    <histories>
      <item value="portal" />
      <item value="Frozen Watermelon" />
      <item value="Watermelon" />
      <item value="Water" />
      <item value="Frozen" />
      <item value="common" />
      <item value="Generic" />
      <item value="Rectificate" />
      <item value="Position" />
      <item value="Postion" />
      <item value="address" />
      <item value="lat" />
      <item value="lon" />
      <item value="Evict" />
      <item value="Icon" />
      <item value="QUICK MSECURITY PAY" />
      <item value="pure" />
      <item value="long Term" />
      <item value="registered" />
      <item value="specify" />
      <item value="retrieve" />
      <item value="internal" />
      <item value="Dispatcher" />
      <item value="maintain" />
      <item value="Lost CAS race to another thread; re-read next" />
      <item value="tail" />
      <item value="Inserts the specified element at the tail of this queue. As the queue is unbounded, this method will never return false." />
      <item value="offer" />
      <item value="Beware that, unlike in most collections, the size method is NOT a constant-time operation. Because of the asynchronous nature of these queues, determining the current number of elements requires a traversal of the elements, and so may report inaccurate results if this collection is modified during traversal. Additionally, the bulk operations addAll, removeAll, retainAll, containsAll, equals, and toArray are not guaranteed to be performed atomically. For example, an iterator operating concurrently with an addAll operation might view only some of the added elements." />
      <item value="This is ordinarily too costly, but may be more efficient than alternatives when traversal operations vastly outnumber mutations, and is useful when you cannot or don't want to synchronize traversals, yet need to preclude interference among concurrent threads. The &quot;snapshot&quot; style iterator method uses a reference to the state of the array at the point that the iterator was created. This array never changes during the lifetime of the iterator, so interference is impossible and the iterator is guaranteed not to throw ConcurrentModificationException. The iterator will not reflect additions, removals, or changes to the list since the iterator was created. Element-changing operations on iterators themselves (remove, set, and add) are not supported. These methods throw UnsupportedOperationException" />
      <item value="making a fresh copy of the underlying array." />
      <item value="promotion" />
      <item value="verification" />
      <item value="Verification" />
      <item value="Result Message" />
      <item value="Gallery" />
      <item value="commission" />
      <item value="Acquires in exclusive uninterruptible mode for thread already in queue. Used by condition wait methods as well as acquire." />
      <item value="Exclusive" />
      <item value="To use this class as the basis of a synchronizer, redefine the following methods, as applicable, by inspecting andor modifying the synchronization state using getState, setState andor compareAndSetState:" />
      <item value="A synchronizer that may be exclusively owned by a thread. This class provides a basis for creating locks and related synchronizers that may entail a notion of ownership. The AbstractOwnableSynchronizer class itself does not manage or use this information. However, subclasses and tools may use appropriately maintained values to help control and monitor access and provide diagnostics." />
      <item value="the synchronization object responsible for this thread parking" />
      <item value="Disables the current thread for thread scheduling purposes unless the permit is available. If the permit is available then it is consumed and the call returns immediately; otherwise the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens: Some other thread invokes unpark with the current thread as the target; or Some other thread interrupts the current thread; or The call spuriously (that is, for no reason) returns. This method does not report which of these caused the method to return. Callers should re-check the conditions which caused the thread to park in the first place. Callers may also determine, for example, the interrupt status of the thread upon return." />
      <item value="The three forms of park each also support a blocker object parameter. This object is recorded while the thread is blocked to permit monitoring and diagnostic tools to identify the reasons that threads are blocked. (Such tools may access blockers using method getBlocker(Thread).) The use of these forms rather than the original forms without this parameter is strongly encouraged. The normal argument to supply as a blocker within a lock implementation is this. These methods are designed to be used as tools for creating higher-level synchronization utilities, and are not in themselves useful for most concurrency control applications. The park method is designed for use only in constructions of the form: while (!canProceed()) { ... LockSupport.park(this); } where neither canProceed nor any other actions prior to the call to park entail locking or blocking. Because only one permit is associated with each thread, any intermediary uses of park could interfere with its intended effects. Sample Usage. Here is a sketch of a first-in-first-out non-reentrant lock class:" />
      <item value="This class associates, with each thread that uses it, a permit (in the sense of the Semaphore class). A call to park will return immediately if the permit is available, consuming it in the process; otherwise it may block. A call to unpark makes the permit available, if it was not already available. (Unlike with Semaphores though, permits do not accumulate. There is at most one.)" />
      <item value="Methods park and unpark provide efficient means of blocking and unblocking threads that do not encounter the problems that cause the deprecated methods Thread.suspend and Thread.resume to be unusable for such purposes: Races between one thread invoking park and another thread trying to unpark it will preserve liveness, due to the permit. Additionally, park will return if the caller's thread was interrupted, and timeout versions are supported. The park method may also return at any other time, for &quot;no reason&quot;, so in general must be invoked within a loop that rechecks conditions upon return. In this sense park serves as an optimization of a &quot;busy wait&quot; that does not waste as much time spinning, but must be paired with an unpark to be effective." />
      <item value="Establishes the heap invariant (described above) in the entire tree, assuming nothing about the order of the elements prior to the call." />
      <item value="A comparison function, which imposes" />
      <item value="compact" />
      <item value="Flattening" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="172" />
        <entry key="ENGLISH" value="173" />
        <entry key="POLISH" value="2" />
        <entry key="FILIPINO" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="SPANISH" value="2" />
        <entry key="ITALIAN" value="1" />
        <entry key="HINDI" value="2" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1660527869128" />
  </component>
  <component name="Settings">
    <option name="translateDocumentation" value="true" />
  </component>
</application>