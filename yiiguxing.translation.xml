<application>
  <component name="AppStorage">
    <option name="newTranslationDialogCollapseDictViewer" value="false" />
    <option name="newTranslationDialogX" value="599" />
    <option name="newTranslationDialogY" value="738" />
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="通知" />
      <item value="震动" />
      <item value="shake" />
      <item value="未知" />
      <item value="静止" />
      <item value="运动" />
      <item value="Illeage" />
      <item value="Elevation" />
      <item value="unified" />
      <item value="Battery" />
      <item value="If the incoming Forwarded header is syntactically valid, append to it" />
      <item value="fire" />
      <item value="Allocator" />
      <item value="schedule" />
      <item value="排序项" />
      <item value="Order Item" />
      <item value="order Item List" />
      <item value="decode" />
      <item value="Phrase" />
      <item value="Award" />
      <item value="settlement" />
      <item value="XXX Hard-coded value, but won't need customization" />
      <item value="A direct byte buffer whose content is a memory-mapped region of a file. Mapped byte buffers are created via the FileChannel.map method. This class extends the ByteBuffer class with operations that are specific to memory-mapped file regions. A mapped byte buffer and the file mapping that it represents remain valid until the buffer itself is garbage-collected. The content of a mapped byte buffer can change at any time, for example if the content of the corresponding region of the mapped file is changed by this program or another. Whether or not such changes occur, and when they occur, is operating-system dependent and therefore unspecified. All or part of a mapped byte buffer may become inaccessible at any time, for example if the mapped file is truncated. An attempt to access an inaccessible region of a mapped byte buffer will not change the buffer's content and will cause an unspecified exception to be thrown either at the time of the access or at some later time. It is therefore strongly recommended that appropriate precautions be taken to avoid the manipulation of a mapped file by this program, or by a concurrently running program, except to read or write the file's content. Mapped byte buffers otherwise behave no differently than ordinary direct byte buffers." />
      <item value="Duplicates" />
      <item value="Not create a new ChannelFutureListener per write operation to reduce GC pressure" />
      <item value="valid" />
      <item value="deallocate" />
      <item value="retained Duplicate" />
      <item value="is Dup" />
      <item value="PUBREL" />
      <item value="Calls ChannelHandlerContext.fireUserEventTriggered(Object) to forward to the next ChannelInboundHandler in the ChannelPipeline. Sub-classes may override this method to change behavior." />
      <item value="Promise" />
      <item value="Inbound" />
      <item value="Post Office" />
      <item value="Office" />
      <item value="encoder" />
      <item value="InheritableThreadLocal values pertaining to this thread. This map is maintained by the InheritableThreadLocal class." />
      <item value="cumulative" />
      <item value="permit" />
      <item value="cancel" />
      <item value="豪华" />
      <item value="自行车" />
      <item value="Quotation" />
      <item value="CANCEL" />
      <item value="COMPLETE" />
      <item value="affirm" />
      <item value="As the queue is unbounded, this method will never return false." />
      <item value="Both head and tail may or may not point to a Node with a non-null item. If the queue is empty, all items must of course be null. Upon creation, both head and tail refer to a dummy Node with null item. Both head and tail are only updated using CAS, so they never regress, although again this is merely an optimization." />
      <item value="CAS, so they never regress, although again this is merely an optimization." />
      <item value="Node with null item. Both head and tail are only updated using" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="215" />
        <entry key="ENGLISH" value="216" />
        <entry key="POLISH" value="2" />
        <entry key="FILIPINO" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="SPANISH" value="2" />
        <entry key="ITALIAN" value="1" />
        <entry key="HINDI" value="3" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1674873615618" />
  </component>
  <component name="Settings">
    <option name="aliTranslateSettings">
      <app-key>
        <option name="appId" value="LTAIbusRyQSiafdy" />
      </app-key>
    </option>
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="primaryLanguage" value="ESPERANTO" />
      </google-translate>
    </option>
    <option name="translateDocumentation" value="true" />
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="101cbe0712549f96" />
      </youdao-translate>
    </option>
  </component>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1679884822335" />
  </component>
  <component name="Translation.Settings">
    <option name="translator" value="MICROSOFT" />
  </component>
  <component name="Translation.States">
    <histories>
      <item value="offline" />
      <item value="online" />
      <item value="个体" />
      <item value="主体" />
      <item value="Domain" />
      <item value="theft" />
      <item value="Screen" />
      <item value="deserializer By Type" />
      <item value="Dispatch" />
      <item value="deserialize" />
      <item value="Volatile access methods are used for table elements as well as elements of in-progress next table while resizing. All uses of the tab arguments must be null checked by callers. All callers also paranoically precheck that tab's length is not zero (or an equivalent check), thus ensuring that any index argument taking the form of a hash value anded with (length - 1) is a valid index. Note that, to be correct wrt arbitrary concurrency errors by users, these checks must operate on local variables, which accounts for some odd-looking inline assignments below. Note that calls to setTabAt always occur within locked regions, and so in principle require only release ordering, not full volatile semantics, but are currently coded as volatile writes to be conservative." />
      <item value="ensure visibility of callable" />
      <item value="Predecessors" />
      <item value="Queued" />
      <item value="acquire" />
      <item value="The correctness of this depends on head being initialized before tail and on head.next being accurate if the current thread is first in queue." />
      <item value="Fair version of tryAcquire. Don't grant access unless recursive call or no waiters or is first." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="12" />
        <entry key="ENGLISH" value="13" />
      </map>
    </option>
  </component>
</application>